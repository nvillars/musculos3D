import * as THREE from 'three';
import ModelLoader from '../ModelLoader.js';

/**
 * HumanMusclesLoader - Adapter to load a glTF (.glb) human muscles model
 * and produce an indexed tree compatible with AnatomyManager expectations.
 */
export default class HumanMusclesLoader {
  constructor(options = {}) {
    this.modelLoader = options.modelLoader || new ModelLoader(options.loaderOptions || {});
    this.defaultModelName = options.defaultModelName || 'human_muscles.glb';
    this.indexPath = options.indexPath || 'assets/models/human_muscles_index.json';
  }

  /**
   * Normalize a mesh name into a canonical id (snake_case)
   */
  normalizeName(name = '') {
    return (name || '')
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '_')
      .replace(/[\/:\\.,()\[\]]+/g, '')
      .replace(/[^a-z0-9_]+/g, '_')
      .replace(/__+/g, '_')
      .replace(/^_+|_+$/g, '');
  }

  /**
   * Heuristic to decide layer (0 superficial, 1 mid, 2 deep)
   */
  detectLayerFromName(name = '') {
    const n = name.toLowerCase();
    if (n.includes('deep') || n.includes('profundo') || n.includes('internal') || n.includes('interno')) return 2;
    if (n.includes('mid') || n.includes('medio') || n.includes('intermediate')) return 1;
    return 0;
  }

  /**
   * Basic region grouping from name prefixes
   */
  detectRegionFromName(name = '') {
    const n = name.toLowerCase();
    if (n.includes('arm') || n.includes('brach') || n.includes('biceps') || n.includes('triceps')) return 'upper_limb';
    if (n.includes('leg') || n.includes('femur') || n.includes('quadriceps') || n.includes('hamstring')) return 'lower_limb';
    if (n.includes('pectoral') || n.includes('rectus') || n.includes('oblique') || n.includes('abdom')) return 'torso';
    if (n.includes('head') || n.includes('neck') || n.includes('orbicular')) return 'head_neck';
    return 'unknown';
  }

  /**
   * Load the model and build an index
   * @param {string} modelPath - filename or path relative to ModelLoader basePath
   */
  async load(modelPath = null, options = {}) {
    const name = modelPath || this.defaultModelName;
    console.log('üîÑ HumanMusclesLoader: Starting to load model:', name);
    
    try {
      const model = await this.modelLoader.loadModel(name, options);
      console.log('‚úÖ HumanMusclesLoader: Model loaded successfully:', model);
      console.log('üìä Model children count:', model.children.length);
      
      // Log all mesh names for debugging
      let meshCount = 0;
      model.traverse((child) => {
        if (child.isMesh) {
          meshCount++;
          console.log(`üìã Mesh ${meshCount}:`, child.name, 'visible:', child.visible);
        }
      });
      console.log('üìä Total meshes found:', meshCount);

    // Try to load optional scaffold index (generated by tooling)
    let scaffold = null;
    try {
      // Use fetch instead of require to avoid webpack bundling issues
      const response = await fetch(this.indexPath);
      if (response.ok) {
        const scaffoldData = await response.json();
        if (scaffoldData && scaffoldData.entries && Array.isArray(scaffoldData.entries)) {
          const map = new Map(scaffoldData.entries.map(e => [e.id, e]));
          scaffold = map;
        }
      }
    } catch (e) {
      scaffold = null; // missing index is fine
    }

    // Build index structures
    const byId = new Map();
    const groups = new Map();
    const allMeshes = new Set();

    model.traverse((child) => {
      if (child.isMesh) {
        // Determine canonical name
        const rawName = child.name || child.userData?.name || '';
        // prefer scaffold id if available (scene root name -> id)
        const scaffoldEntry = scaffold ? scaffold.get(rawName) || scaffold.get((rawName||'').toUpperCase()) : null;
        const canonical = scaffoldEntry && scaffoldEntry.id ? scaffoldEntry.id : (this.normalizeName(rawName) || `mesh_${child.id}`);

        // Determine type and layer heuristics
        const isMuscle = /muscle|musc|biceps|triceps|pectoral|quadriceps|hamstring|rectus|oblique|orbicular|sternocleidomastoid|scm/i.test(rawName);
        const type = isMuscle ? 'muscle' : 'structure';
        let layer = this.detectLayerFromName(rawName);
        let region = this.detectRegionFromName(rawName);
        // override from scaffold when present
        if (scaffoldEntry) {
          if (scaffoldEntry.layer != null) layer = scaffoldEntry.layer;
          if (scaffoldEntry.region) region = scaffoldEntry.region;
        }

        // Assign userData preserving existing fields
        child.userData = {
          ...(child.userData || {}),
          canonicalName: canonical,
          type,
          system: 'musculoskeletal',
          layer,
          region,
          originalName: rawName,
          label: scaffoldEntry ? scaffoldEntry.label : (child.userData && child.userData.label ? child.userData.label : null)
        };

        // Ensure material is unique per mesh to allow highlighting safely
        if (child.material) {
          try {
            child.material = Array.isArray(child.material) ? child.material.map(m => m.clone()) : child.material.clone();
          } catch (e) {
            // ignore clone failures
          }
        }

        byId.set(canonical, child);
        allMeshes.add(child);

        // group by region
        if (!groups.has(region)) groups.set(region, new Set());
        groups.get(region).add(child);
      }
    });

    const index = { byId, groups, allMeshes, model };
    console.log('‚úÖ HumanMusclesLoader: Index created successfully');
    console.log('üìä Index stats:', {
      byIdCount: byId.size,
      groupsCount: groups.size,
      allMeshesCount: allMeshes.size
    });
    return index;
    } catch (error) {
      console.error('‚ùå HumanMusclesLoader: Error loading model:', error);
      throw error;
    }
  }
}
